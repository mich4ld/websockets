# Websocket server 
#### Simplified websocket server implementation in TypeScript

<img 
  width="620px" 
  src="https://user-images.githubusercontent.com/43048524/168474871-c24d0ead-dac3-4e31-aa78-3d9b9e90f8b6.jpg"
  alt="hide-pain-harold-computer" 
/>

## Painful process
Websocket protocol was harder to implement than I initially thought. I learned a lot about networking and dealing with bitwise operations. Although my implementation is not perfect, it can handle larger files (like images and videos).

### Two main challenges
Handling large WS frames is hard because we have to deal with frame fragmentation over TCP data stream. Second major challenge is parsing WS frame.

### Good resources to learn how Websocket works
1. Wikipedia: https://en.wikipedia.org/wiki/WebSocket
2. WebSockets Crash Course - Handshake, Use-cases, Pros & Cons and more: https://youtu.be/2Nt-ZrNP22A
3. WebSocket Tutorial - How WebSockets Work: https://youtu.be/pNxK8fPKstc
4. WebSocket RFC: https://www.rfc-editor.org/rfc/rfc6455


## How it works?

### First stage - WebSocket handshake over HTTP protocol
Client sends special HTTP request with special headers:
```yml
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

Server response:
```yml
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

As you can see there are a few WS specific headers like: `Sec-WebSocket-Key`, `Sec-WebSocket-Protocol`, `Sec-WebSocket-Version`. 
What is `Sec-WebSocket-Key`? It's an unique key generated by client. Server needs it for generating `Sec-WebSocket-Accept` header.

According to official RFC and Wikipedia, `Sec-WebSocket-Accept` value is base64 encoded SHA-1 hash of `Sec-WebSocket-Key` combined with fixed UUID `258EAFA5-E914-47DA-95CA-C5AB0DC85B1`.

```ts
function createWsAcceptKey(wsKey: string): string {
    const uuid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; // constant UUID definied in WS docs
    const dataToHash = wsKey + uuid

    return createHash('sha1')
        .update(Buffer.from(dataToHash))
        .digest('base64');
}
```

#### Finalizing WebSocket handshake
Just send required headers like `Upgrade`, `Connection` and `Sec-WebSocket-Accept`. Remember about HTTP status code `101` (Switching Protocols) and body with extra blank line at the end.
```ts
function finalizeHandshake(res: ServerResponse, wsAcceptKey: string) {
    res.statusCode = 101;
    
    // set headers:
    res.setHeader('Upgrade', 'websocket');
    res.setHeader('Connection', 'Upgrade');
    res.setHeader('Sec-WebSocket-Accept', wsAcceptKey);
    
    res.write('\r\n');
    res.end();
}
```

### Second stage - parsing WebSocket frame
<img src="https://user-images.githubusercontent.com/43048524/168477955-780ff531-b2e3-4746-bc9a-549204d6c8c9.png" />

Important reference: https://www.rfc-editor.org/rfc/rfc6455#section-5.2


1 byte = 8 bits

#### Important concepts for parsing frame
1. What is endianess? (https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/)
2. Bitwise operators (https://en.wikipedia.org/wiki/Bitwise_operation)

#### Reuse TCP connection socket
```ts
const server = new Server((req, res) => {
  ...
  finalizeHandshake(res, wsAcceptKey);
   
  // We have to reuse socket from HTTP request. Now we can operate on TCP level
  req.socket.on('data', (buff) => {})
 ```

#### Parsing first byte of frame
![image](https://user-images.githubusercontent.com/43048524/168479784-566fb245-4e01-4088-a043-0c35fe40c7d8.png)

Read first byte from buffer:
```ts
req.socket.on('data', (buff) => {
  let byteOffset = 0;
  const firstByte = buff.readUint8(byteOffset);
})
```

#### How to read bits (1 byte = 8 bits)?
Our `firstByte` variable is interpreted by Node.js as decimal number - How to get all information from byte? We have to use bitwise operators for operations on bits.

##### How to read n-bit? Example:
```ts
...
const firstByte = buff.readUint8(byteOffset); // 129 as decimal = 10000001 as binary

const firstBit = (firstByte >> 7) & 0x1; // 1
const secondBit = (firstByte >> 6) & 0x1; // 0
const thirdBit = (firstByte >> 5) & 0x1; // 0
```

##### How to read last n-bits? Example:
```ts
...
const firstByte = buff.readUint8(byteOffset); // 129 as decimal = 10000001 as binary
const lastFourBits = firstByte & 15;  // 15 as decimal = 00001111 as binary
```

#### Let's actually parse first byte
```ts
let byteOffset = 0;
const firstByte = buff.readUint8(byteOffset);

const fin = Boolean((firstByte >> 7) & 0x1);

const rsv1 = (firstByte >> 6) & 0x1;
const rsv2 = (firstByte >> 5) & 0x1;
const rsv3 = (firstByte >> 4) & 0x1;

const opcode = firstByte & 15;
```

`fin` - our first bit in frame. Indicates that this is the final fragment in a message. `0` - false, `1` - true;

`rsv1`, `rsv2`, `rsv3` - we don't really care about those reserved fields. They are useful for extending WebSocket protocol.

According to RFC: "MUST be 0 unless an extension is negotiated that defines meanings for non-zero values.";

`opcode` - four bits. Defines the type of payload data.

According to RFC: 
- `0x0`  denotes a continuation frame
- `0x1` denotes a text frame
- `0x2` denotes a binary frame
- `0x8` denotes a connection close
- `0x9` denotes a ping
- `0xA` denotes a pong

#### Parsing second byte of frame
![image](https://user-images.githubusercontent.com/43048524/168483384-c0449989-50ea-4def-bfcd-c4f345d49b1c.png)

```ts
byteOffset++;   // 1
const secondByte = buff.readUInt8(byteOffset);

const mask = Boolean((secondByte >> 7) & 0x1);
let payloadLen = secondByte & 127;
```

`mask` - (1 bit). Defines whether the payload is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the payload.

More about `MASK`: https://security.stackexchange.com/questions/113297/whats-the-purpose-of-the-mask-in-a-websocket

`payloadLen` - (7 last bits). the length of payload data. 

According to RFC: "if 0-125, that is the payload length.  If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length.  If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length."


